<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><title>Bootstrapping on Bare Metal: Fitting a FORTH in 510 bytes — NieDżejkob's ramblings</title><link rel=stylesheet href=https://niedzejkob.p4.team/style.css><link rel=icon href=https://niedzejkob.p4.team/icon.png><link rel=canonical href=https://niedzejkob.p4.team/bootstrap/miniforth/><link rel=alternate type=application/atom+xml href=/atom.xml><meta property=og:type content=website><meta property=og:title content="Bootstrapping on Bare Metal: Fitting a FORTH in 510 bytes"><meta property=og:url content=https://niedzejkob.p4.team/bootstrap/miniforth/><meta property=og:image content=https://niedzejkob.p4.team/icon.png><body class=theme-default><header><div class=main-column><a href=/> <img id=icon src=/icon.png> <span><b>NieDżejkob</b>'s ramblings</span> </a></div></header><main><h1 class=title>Bootstrapping on Bare Metal: Fitting a FORTH in 510 bytes</h1><p class="subtitle page-metadata">June 10, 2021 · 38 minute read<p>Software is full of circular dependencies if you look deep enough. Compilers written in the language they compile are the most obvious example, but not the only one. To compile a kernel, you need a running kernel. How do you break this cycle? Since the <a href=http://bootstrappable.org/>bootstrapping problem</a> has first come to my attention, I've been drawn to this unique area of software engineering. Not out of fear that someone would try to implement a <a href=http://users.ece.cmu.edu/%7Eganger/712.fall02/papers/p761-thompson.pdf>trusting trust</a> attack, but simply as an interesting challenge.</p><span id=continue-reading></span><p>11 years ago, <a href=https://www.reddit.com/r/programming/comments/9x15g/programming_thought_experiment_stuck_in_a_room/><em>vanjos72</em> described on Reddit</a> what he calls a thought experiment: what if you were locked in a room with an IBM PC, with no operating system on it? What would be the minimum amount of software you'd need to start out with to bootstrap back into comfort?<p>As it happens, I've recently found myself with an abundance of free time on my hands, so I've decided to make this more than a thought experiment. Alas, my computer didn't come equipped with front panel switches, so some software needs to be present on the computer already...<p>The absolutely minimal option would be a simple program that accepts input from the keyboard, and then jumps to it. Since the keyboard input routines in the BIOS implement alt+numpad escape codes, you don't even need to write any base conversion code.<sup class=footnote-reference><a href=#ascii-x86>1</a></sup> Moreover, the loop doesn't even need an end condition — just write to the buffer backwards until you run into the existing code and overwrite the jump target. This approach takes a mere 14 bytes:<pre style=background-color:#272822;>
<code class=language-lst data-lang=lst><span style=color:#75715e;>6a00    </span><span style=color:#f92672;>push </span><span style=color:#66d9ef;>word </span><span style=color:#ae81ff;>0
</span><span style=color:#75715e;>07      </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>es
</span><span style=color:#75715e;>fd      </span><span style=color:#f92672;>std
</span><span style=color:#75715e;>bf1e7c  </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>buffer</span><span style=color:#f8f8f2;>+</span><span style=color:#ae81ff;>16</span><span style=color:#75715e;> ; Adjust to taste. Beware of fenceposting.
       </span><span style=color:#a6e22e;>input_loop:
</span><span style=color:#75715e;>b400    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ah</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0
</span><span style=color:#75715e;>cd16    </span><span style=color:#f92672;>int </span><span style=color:#ae81ff;>0x16
</span><span style=color:#75715e;>aa      </span><span style=color:#f92672;>stosb
</span><span style=color:#75715e;>ebf9    </span><span style=color:#f92672;>jmp </span><span style=color:#a6e22e;>short input_loop
       buffer:
</span></code></pre><p>However, I do not find the prospect of entering code this way anywhere near appealing. I've decided that, since the BIOS loads an entire sector anyway, any bootstrap seed that fits into the bootsector is fair game.<sup class=footnote-reference><a href=#disagree>2</a></sup> Obviously, one would want to maximize the utility of the chosen program. What is the most powerful thing we can fit in 510 bytes?<p>Many interesting sector-sized programs have been written by Oscar Toledo. This includes many games, such as <a href=https://github.com/nanochess/cubicDoom>a DooM-like raycasting game</a> or a <a href=https://github.com/nanochess/Toledo-Atomchess>chess AI</a>, as well as a basic <a href=https://github.com/nanochess/bootBASIC>BASIC interpreter</a>, but the most perhaps the most relevant one for our usecase is <a href=https://github.com/nanochess/bootOS>bootOS</a>:<blockquote><p><code>bootOS</code> is a monolithic operating system that fits in one boot sector. It's able to load, execute, and save programs. Also keeps a filesystem.</blockquote><p>It exposes its filesystem routines with an interrupt interface, and includes a builtin command that allows creating a file by typing in its hexdump. Very neat, but clearly mostly intended as a multiplexer between other sector-sized programs. What I would seek is a solution that minimizes typing in hand-assembled machine code. Ideally, it would be a programming language, but one that, unlike BASIC, can be extended at runtime. If you've read the title of this post, you already know what I settled on — as it turns out, it's possible to fit a barebones FORTH in a bootsector. You can see the code in the <a href=https://github.com/NieDzejkob/miniforth>Miniforth repository on GitHub</a>, but I will include most of it here.<p>The entire FORTH takes, at this moment, 504 bytes. As you might expect, the development process involved being on a perpetual lookout for byte-saving opportunities. However, when I published what I thought was quite tightly optimized code, <a href=https://twitter.com/ilyakurdyukov>Ilya Kurdyukov</a> came along and managed to find 24 bytes to be saved! I promptly reinvested this saved space in new features.<h2 id=a-primer-on-forth>A primer on FORTH</h2><p><em>If you've ever written anything in FORTH, you can safely skip this section.</em><p>FORTH is a stack-based language. For example, a number will push its value onto the stack, while the <code>+</code> <em>word</em> will pop two numbers and push their sum. A common debugging utility, but one not included in Miniforth, is the <code>.s</code> word, which prints the contents of the stack.<pre>
<b>1 2 3 + .s</b> &LT2> 1 5  ok
</pre><p>The user can define their own words with <code>:</code> and <code>;</code>. For example:<pre>
<b>: double dup + ;</b>  ok
<b>3 double .</b> 6  ok
</pre><p>This defines the word <code>double</code>, which does the same thing as <code>dup +</code>. <code>dup</code>, by the way, is one of FORTH's stack manipulation words. It duplicates the top element on the stack:<pre>
<b>42 dup .s</b> &LT2> 42 42  ok
</pre><p>This is basically the entire language. There are some standard facilities for conditionals and loops, but we don't need to concern ourselves with those for now, as they can be built on top of Miniforth later on.<p>To talk about the effect a word has on the state of the stack, we use a notation like this:<pre style=background-color:#272822;>
<code><span style=color:#f8f8f2;>dup ( a -- a a )
swap ( a b -- b a )
</span></code></pre><p>The list before the <code>--</code> are the inputs, with the top of stack listed last. After the <code>--</code>, we list the outputs, which start at the same stack depth. This lets us succintly describe the common aspects of a word.<h2 id=threaded-code>Threaded code</h2><p>While some FORTH systems do include full-blown, optimizing compilers similar to those one'd see in a typical programming language, there is a much simpler strategy. After all, everything a FORTH word can do is execute other words, so a sequence of <code>call</code> instructions gets us very close:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>DOUBLE:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>DUP
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>PLUS
    </span><span style=color:#f92672;>ret
</span></code></pre><p>However, this ties up the hardware <code>x86</code> stack for the return stack, making us handroll a separate stack for the actual user-level stack (known as the <em>parameter stack</em>). As accessing the parameter stack is much more common, we'd like to use the <code>push</code> and <code>pop</code> instructions for that, and instead handroll a mechanism similar to <code>call</code>. Firstly, let's simply store a list of pointers to words:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>DOUBLE:
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>DUP
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>PLUS
</span></code></pre><p>The way this comes to life is that each primitive word fetches the address of the next word from memory, and jumps to it. A pointer to this sequence of pointers is kept in <code>SI</code>, so that the <code>lodsw</code> instruction allows for easy processing of this list:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>DUP:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>ax

    </span><span style=color:#f92672;>lodsw
    jmp </span><span style=font-style:italic;color:#fd971f;>ax

</span><span style=color:#a6e22e;>PLUS:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>add </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>ax

    </span><span style=color:#f92672;>lodsw
    jmp </span><span style=font-style:italic;color:#fd971f;>ax
</span></code></pre><p>This common code can be abstracted away into a macro, which is traditionally called <code>NEXT</code>:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#66d9ef;>%macro </span><span style=color:#a6e22e;>NEXT </span><span style=color:#ae81ff;>0
    </span><span style=color:#f92672;>lodsw
    jmp </span><span style=font-style:italic;color:#fd971f;>ax
</span><span style=color:#66d9ef;>%endmacro
</span></code></pre><p>This mechanism, by the way, is known as <em>threaded code</em>. No relation to the concurrency primitive.<p>What happens if one compiled word calls another one, though? This is where the return stack comes in. It might feel natural to use the <code>BP</code> register for this stack pointer. However, in 16-bit x86, there isn't actually a <code>[bp]</code> addressing mode. The closest you can get is <code>[bp+imm8]</code>, which means that accessing the memory at <code>bp</code> wastes a byte to specify that you do not want an offset. This is why I use the <code>di</code> register for the return stack instead. Overall, this choice saves 4 bytes.<p>Anyway, here is how the return stack is used to handle compiled words calling each other. Pushing onto the return stack is particularily nice, since it's just the <code>stosw</code> instruction.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>DOUBLE:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>DOCOL
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>DUP
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>PLUS
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>EXIT

DOCOL:</span><span style=color:#75715e;>   ; short for "do colon word"
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#75715e;> ; used here as `mov ax, si`, but swaps with
                ; ax are only one byte, while `mov`s are two bytes
    </span><span style=color:#f92672;>stosw
    pop </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#75715e;> ; grab the pointer pushed by `call`
    </span><span style=color:#a6e22e;>NEXT

EXIT:
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, [</span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>]
    </span><span style=color:#a6e22e;>NEXT
</span></code></pre><p>This is pretty much the execution strategy used by Miniforth, with one simple, but significant improvement — the value on top of the stack is stored in the <code>BX</code> register. This allows skipping a <code>push</code> and <code>pop</code> in many primitives:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>PLUS:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>add </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#a6e22e;>NEXT

DROP:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#a6e22e;>NEXT

DUP:
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#a6e22e;>NEXT
</span></code></pre><p>One case is still unresolved, though. What happens if a word contains a number, such as <code>: DOUBLE 2 * ;</code>? This is handled by <code>LIT</code>, which will fetch the literal that follows out of the pointer stream:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>DOUBLE:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>DOCOL
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>LIT</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>2
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>MULT
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>EXIT

LIT:
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>lodsw
    xchg </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#a6e22e;>NEXT
</span></code></pre><h2 id=the-dictionary>The Dictionary</h2><p>FORTH needs a way to locate the implementation of the words the user types in. This is the role of the <em>dictionary</em>. I use a structure similar to many other small-scale FORTHs — a singly linked list of word headers, directly prepended before the code of each word. Out of tradition, the head of the list is kept in a variable called <code>LATEST</code>.<p><img src=https://niedzejkob.p4.team/bootstrap/miniforth/dictionary.svg><p>The most significant bits of the name length field also store some flags:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>F_IMMEDIATE </span><span style=color:#66d9ef;>equ </span><span style=color:#ae81ff;>0x80
</span><span style=color:#a6e22e;>F_HIDDEN    </span><span style=color:#66d9ef;>equ </span><span style=color:#ae81ff;>0x40
</span><span style=color:#a6e22e;>F_LENMASK   </span><span style=color:#66d9ef;>equ </span><span style=color:#ae81ff;>0x1f
</span></code></pre><p>If a word is marked as <code>IMMEDIATE</code>, it will be executed immediately, even if we're currently compiling a definition. For example, this is used to implement <code>;</code>. If a word is marked as <code>HIDDEN</code>, it is ignored when searching through the dictionary. Apart from being used as a rudimentary encapsulation mechanism, this can be used to implement the traditional FORTH semantics where a word definition can refer to the previous word with the same name (and <code>RECURSE</code> is used when you want the definition currently being compiled). However, towards the end of development, I have removed the code that actually does this from the default implementation of <code>:</code> and <code>;</code>.<h2 id=compression>Compression</h2><p>It is usually not worth it to use compression when both the decompressor and its payload have to fit in merely 512 bytes. However, in a FORTH implementation, one thing that's repeated very often is the implementation of <code>NEXT</code>.<pre style=background-color:#272822;>
<code class=language-lst data-lang=lst><span style=color:#75715e;>ad      </span><span style=color:#f92672;>lodsw
</span><span style=color:#75715e;>ffe0    </span><span style=color:#f92672;>jmp </span><span style=font-style:italic;color:#fd971f;>ax
</span></code></pre><p>We could try to save some bytes by replacing these with jumps to a shared copy. However, a short jump still takes two bytes — not a significant saving. As it turns out, a special compression scheme that can only handle this one repeating pattern is worth it, as long as you combine it with the following observation: <code>NEXT</code> is almost always followed by the dictionary entry of the next primitive, of which the link field is predictable.<p>I chose to implement a compression scheme where every <code>0xff</code> byte is replaced with <code>NEXT</code>, followed by a link field, which is computed based on the previous occurence of an <code>0xff</code> byte. This strategy saved 19 bytes when I introduced it.<sup class=footnote-reference><a href=#compress-savings>3</a></sup><p>At first, I used a <code>0x90</code> byte for this — after all, it's the opcode of <code>nop</code>, which I'm definitely not going to be using. However, the byte can still occur in the immediate bytes of an instruction. It wasn't a problem at first, but when the code was shifting around in memory, various addresses and offsets became <code>0x90</code> often enough to be a nuisance. <code>0xff</code> doesn't seem to have this problem.<p>To create a link, we copy the value of <code>LATEST</code> to the decompressor output, and update <code>LATEST</code> to point to the word we've just written. This can be done in a very compact sequence of instructions, but it still takes enough bytes that it is worthy it to factor it out as a subroutine — it is also used by the implementation of <code>:</code>, which creates dictionary entries at runtime.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>; Creates a dictionary linked list link at DI.
</span><span style=color:#a6e22e;>MakeLink:
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>xchg </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>LATEST</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#75715e;>  ; AX now points at the old entry, while
                       ; LATEST and DI point at the new one.
    </span><span style=color:#f92672;>stosw
    ret
</span></code></pre><p>The decompressor used to make use of an interesting trick, where instead of a short forward jump, an opcode is placed so the immediate argument it requires eats the instructions we want to jump over. That is, instead of<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#f92672;>jmp </span><span style=color:#a6e22e;>short .after
.write:
    </span><span style=color:#f92672;>stosb
</span><span style=color:#a6e22e;>.after:
</span></code></pre><p>you write<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>3c      </span><span style=color:#66d9ef;>db </span><span style=color:#ae81ff;>0x3c</span><span style=color:#75715e;> ; skip the stosb below by comparing its opcode with AL
    </span><span style=color:#a6e22e;>.write:
aa      </span><span style=color:#f92672;>stosb
</span></code></pre><p>Thus, if some other code jumps to <code>.write</code>, the <code>stosb</code> executes, but this codepath just does <code>cmp al, 0xaa</code>. At first, I didn't think of the <code>cmp al</code> instruction, and a <code>mov</code> into a throwaway register instead. This <a href=https://twitter.com/NieDzejkob/status/1401557309118103560>backfired spectacularily</a> because of my inability to actually pick a register that can be safely overwritten.<p>Ilya Kurdyukov then demonstrated <a href=https://twitter.com/ilyakurdyukov/status/1401736488681979906>that the same bytecount can be achieved without this kind of "magic"</a>. An analogous modification allowed me to remove the other occurence of this trick too. The essence is that instead of trying to skip over the <code>stosb</code>, we execute it unconditionally before the codepaths branch, and then essentially undo it with <code>dec di</code> if necessary:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>SPECIAL_BYTE </span><span style=color:#66d9ef;>equ </span><span style=color:#ae81ff;>0xff

    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>CompressedData
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>CompressedBegin
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>cx</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>COMPRESSED_SIZE
.decompress:
    </span><span style=color:#f92672;>lodsb
    stosb
    cmp </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>SPECIAL_BYTE
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>short .not_special
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0xffad</span><span style=color:#75715e;> ; lodsw / jmp ax
    </span><span style=color:#f92672;>stosw
    mov </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0xe0
    </span><span style=color:#f92672;>stosb
    call </span><span style=color:#a6e22e;>MakeLink
.not_special:
    </span><span style=color:#f92672;>loop </span><span style=color:#a6e22e;>.decompress
</span></code></pre><p>Actually generating the compressed stream is more involved. Because I want jumps between the compressed and uncompressed portions to work, the assembler needs to believe it is writing the code at the location it will actually run. I first attempted to do this by adjusting the <code>org</code> after each <code>SPECIAL_BYTE</code>, but unfortunately, yasm didn't like that.<pre style=background-color:#272822;>
<code><span style=color:#f8f8f2;>boot.s:137: error: program origin redefined
</span></code></pre><p>Clearly, a separate post-processing step is necessary. I wrote a macro to shim the bytes the decompressor will insert:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#66d9ef;>%macro </span><span style=color:#a6e22e;>compression_sentinel </span><span style=color:#ae81ff;>0
    </span><span style=color:#66d9ef;>db </span><span style=color:#a6e22e;>SPECIAL_BYTE
    </span><span style=color:#66d9ef;>dd </span><span style=color:#ae81ff;>0xdeadbeef
</span><span style=color:#66d9ef;>%endmacro
</span></code></pre><p>This has the added benefit of allowing a simple automated way to verify that no <code>SPECIAL_BYTE</code>s slipped in by accident.<p>I still had to allocate the space for the compressed data. I choose the following layout:<ol><li>Uncompressed code starts at <code>7C00</code> — initialization, decompression, and the outer interpreter.<li>Compressed data immediately follows, filling up the bootsector up to a moment before <code>7E00</code>.<li>The decompression buffer is allocated immediately after that, which is where <code>yasm</code> outputs the target contents.</ol><p>To achieve this, I needed to know exactly how much space needs to be allocated for the compressed data. First, I calculate the exact number of bytes saved by incrementing a counter in the <code>compression_sentinel</code> macro:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#66d9ef;>%assign </span><span style=color:#a6e22e;>savings </span><span style=color:#ae81ff;>0

</span><span style=color:#66d9ef;>%macro </span><span style=color:#a6e22e;>compression_sentinel </span><span style=color:#ae81ff;>0
</span><span style=color:#66d9ef;>%assign </span><span style=color:#a6e22e;>savings savings</span><span style=color:#f8f8f2;>+</span><span style=color:#ae81ff;>4
    </span><span style=color:#66d9ef;>db </span><span style=color:#a6e22e;>SPECIAL_BYTE
    </span><span style=color:#66d9ef;>dd </span><span style=color:#ae81ff;>0xdeadbeef
</span><span style=color:#66d9ef;>%endmacro
</span></code></pre><p>Then, I simply subtract this from the size of the uncompressed segment:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>CompressedData:
    </span><span style=color:#66d9ef;>times </span><span style=color:#a6e22e;>COMPRESSED_SIZE </span><span style=color:#66d9ef;>db </span><span style=color:#ae81ff;>0xcc

</span><span style=color:#a6e22e;>CompressedBegin:
</span><span style=color:#75715e;>; ...
</span><span style=color:#a6e22e;>CompressedEnd:

COMPRESSED_SIZE </span><span style=color:#66d9ef;>equ </span><span style=color:#a6e22e;>CompressedEnd </span><span style=color:#f8f8f2;>- </span><span style=color:#a6e22e;>CompressedBegin </span><span style=color:#f8f8f2;>- </span><span style=color:#a6e22e;>savings
</span></code></pre><p>The post-processing is done by a simple Python script:<pre style=background-color:#272822;>
<code class=language-python data-lang=python><span style=color:#f8f8f2;>SPECIAL_BYTE </span><span style=color:#f92672;>= </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\xff</span><span style=color:#e6db74;>'
</span><span style=color:#f8f8f2;>SENTINEL </span><span style=color:#f92672;>= </span><span style=color:#f8f8f2;>SPECIAL_BYTE </span><span style=color:#f92672;>+ </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\xef\xbe\xad\xde</span><span style=color:#e6db74;>'

</span><span style=color:#f92672;>with </span><span style=color:#66d9ef;>open</span><span style=color:#f8f8f2;>(</span><span style=color:#e6db74;>'raw.bin'</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>'rb'</span><span style=color:#f8f8f2;>) </span><span style=color:#f92672;>as </span><span style=color:#f8f8f2;>f:
    data </span><span style=color:#f92672;>= </span><span style=color:#f8f8f2;>f.read()

output_offset </span><span style=color:#f92672;>= </span><span style=color:#f8f8f2;>data.index(</span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\xcc</span><span style=color:#e6db74;>' </span><span style=color:#f92672;>* </span><span style=color:#ae81ff;>20</span><span style=color:#f8f8f2;>)
chunks </span><span style=color:#f92672;>= </span><span style=color:#f8f8f2;>data[output_offset:].lstrip(</span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\xcc</span><span style=color:#e6db74;>'</span><span style=color:#f8f8f2;>).split(SENTINEL)

</span><span style=color:#f92672;>assert </span><span style=color:#f8f8f2;>SPECIAL_BYTE </span><span style=color:#f92672;>not in </span><span style=color:#f8f8f2;>chunks[</span><span style=color:#ae81ff;>0</span><span style=color:#f8f8f2;>]
compressed </span><span style=color:#f92672;>= </span><span style=font-style:italic;color:#66d9ef;>bytearray</span><span style=color:#f8f8f2;>(chunks[</span><span style=color:#ae81ff;>0</span><span style=color:#f8f8f2;>])

</span><span style=color:#f92672;>for </span><span style=color:#f8f8f2;>chunk </span><span style=color:#f92672;>in </span><span style=color:#f8f8f2;>chunks[</span><span style=color:#ae81ff;>1</span><span style=color:#f8f8f2;>:]:
    </span><span style=color:#f92672;>assert </span><span style=color:#f8f8f2;>SPECIAL_BYTE </span><span style=color:#f92672;>not in </span><span style=color:#f8f8f2;>chunk
    compressed.extend(SPECIAL_BYTE)
    compressed.extend(chunk)

</span><span style=color:#75715e;># Make sure that exactly the right amount of space is allocated
# for the compressed data.
</span><span style=color:#f92672;>assert </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\xcc</span><span style=color:#e6db74;>' </span><span style=color:#f92672;>* </span><span style=color:#66d9ef;>len</span><span style=color:#f8f8f2;>(compressed) </span><span style=color:#f92672;>in </span><span style=color:#f8f8f2;>data
</span><span style=color:#f92672;>assert </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\xcc</span><span style=color:#e6db74;>' </span><span style=color:#f92672;>* </span><span style=color:#f8f8f2;>(</span><span style=color:#66d9ef;>len</span><span style=color:#f8f8f2;>(compressed) </span><span style=color:#f92672;>+ </span><span style=color:#ae81ff;>1</span><span style=color:#f8f8f2;>) </span><span style=color:#f92672;>not in </span><span style=color:#f8f8f2;>data

output </span><span style=color:#f92672;>= </span><span style=color:#f8f8f2;>data[:output_offset] </span><span style=color:#f92672;>+ </span><span style=color:#f8f8f2;>compressed

</span><span style=color:#66d9ef;>print</span><span style=color:#f8f8f2;>(</span><span style=color:#66d9ef;>len</span><span style=color:#f8f8f2;>(output), </span><span style=color:#e6db74;>'bytes used'</span><span style=color:#f8f8f2;>)
output </span><span style=color:#f92672;>+= </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\x00</span><span style=color:#e6db74;>' </span><span style=color:#f92672;>* </span><span style=color:#f8f8f2;>(</span><span style=color:#ae81ff;>510 </span><span style=color:#f92672;>- </span><span style=color:#66d9ef;>len</span><span style=color:#f8f8f2;>(output))
output </span><span style=color:#f92672;>+= </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\x55\xaa</span><span style=color:#e6db74;>'

</span><span style=color:#f92672;>with </span><span style=color:#66d9ef;>open</span><span style=color:#f8f8f2;>(</span><span style=color:#e6db74;>'boot.bin'</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>'wb'</span><span style=color:#f8f8f2;>) </span><span style=color:#f92672;>as </span><span style=color:#f8f8f2;>f:
    f.write(output)
</span></code></pre><p>The same script also generates an extended disk image, which contains some smoke-testing code in block 1:<pre style=background-color:#272822;>
<code class=language-python data-lang=python><span style=color:#f8f8f2;>output </span><span style=color:#f92672;>+= </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\x00</span><span style=color:#e6db74;>' </span><span style=color:#f92672;>* </span><span style=color:#ae81ff;>512
</span><span style=color:#f8f8f2;>output </span><span style=color:#f92672;>+= </span><span style=color:#66d9ef;>open</span><span style=color:#f8f8f2;>(</span><span style=color:#e6db74;>'test.fth'</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>'rb'</span><span style=color:#f8f8f2;>).read().replace(</span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>'</span><span style=color:#ae81ff;>\n</span><span style=color:#e6db74;>'</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>' '</span><span style=color:#f8f8f2;>)
output </span><span style=color:#f92672;>+= </span><span style=font-style:italic;color:#66d9ef;>b</span><span style=color:#e6db74;>' ' </span><span style=color:#f92672;>* </span><span style=color:#f8f8f2;>(</span><span style=color:#ae81ff;>2048 </span><span style=color:#f92672;>- </span><span style=color:#66d9ef;>len</span><span style=color:#f8f8f2;>(output))

</span><span style=color:#f92672;>with </span><span style=color:#66d9ef;>open</span><span style=color:#f8f8f2;>(</span><span style=color:#e6db74;>'test.img'</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>'wb'</span><span style=color:#f8f8f2;>) </span><span style=color:#f92672;>as </span><span style=color:#f8f8f2;>f:
    f.write(output)
</span></code></pre><p><code>compression_sentinel</code> is most often used by the <code>defcode</code> macro, which creates the dictionary entry for a primitive word. It takes a label (which can then be used to jump to the implementation of some word), the name of the word as a string, and optionally, some flags to be ORed into the length field:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>; defcode PLUS, "+"
; defcode SEMI, ";", F_IMMEDIATE
</span><span style=color:#66d9ef;>%macro </span><span style=color:#a6e22e;>defcode </span><span style=color:#ae81ff;>2</span><span style=color:#f8f8f2;>-</span><span style=color:#ae81ff;>3 0
    </span><span style=color:#a6e22e;>compression_sentinel
</span><span style=color:#66d9ef;>%strlen </span><span style=color:#a6e22e;>namelength %</span><span style=color:#ae81ff;>2
    </span><span style=color:#66d9ef;>db </span><span style=color:#a6e22e;>%</span><span style=color:#ae81ff;>3 </span><span style=color:#a6e22e;>| namelength</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>%</span><span style=color:#ae81ff;>2
</span><span style=color:#a6e22e;>%</span><span style=color:#ae81ff;>1</span><span style=color:#a6e22e;>:
</span><span style=color:#66d9ef;>%endmacro
</span></code></pre><p>This is then used to define the primitives. The code essentially falls-through into a <code>defcode</code>:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode PLUS</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"+"
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>add </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax

</span><span style=color:#a6e22e;>defcode MINUS</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"-"
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>sub </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax

</span><span style=color:#a6e22e;>defcode PEEK</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"@"
</span><span style=color:#75715e;>    ; ...
</span></code></pre><p>However, <code>DOCOL</code>, <code>EXIT</code> and <code>LIT</code> also use the compression mechanism for their <code>NEXT</code>s. Since the link field is still written out, this essentially creates bogus dictionary entries. Fortunately, the first opcode of <code>EXIT</code> and <code>LIT</code> has the <code>F_HIDDEN</code> bit set, so this is not a problem:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>CompressedBegin:

DOCOL:
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>si
    </span><span style=color:#f92672;>stosw
    pop </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#75715e;> ; grab the pointer pushed by `call`
    </span><span style=color:#a6e22e;>compression_sentinel

LIT:
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>lodsw
    xchg </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#a6e22e;>compression_sentinel

EXIT:
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, [</span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>]

</span><span style=color:#a6e22e;>defcode PLUS</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"+"
</span><span style=color:#75715e;>    ; ...
</span></code></pre><h2 id=variables>Variables?</h2><p>Immediate load instructions tend to have shorter encodings than loads from memory:<pre style=background-color:#272822;>
<code class=language-lst data-lang=lst><span style=color:#75715e;>be3412    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0x1234
</span><span style=color:#75715e;>8b363412  </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, [</span><span style=color:#ae81ff;>0x1234</span><span style=color:#f8f8f2;>]
</span></code></pre><p>This is why Miniforth stores most of its variables in the immediate fields of instructions. Of course, this means that the address of these variables will change on every edit of the code, which is problematic, since we will be wanting to access these variables in FORTH code. The typical way of exposing a variable is to create a word that pushes its address. However, that's way too expensive with our constraints. What I settled on is pushing the addresses onto the stack at startup. This can be done with only 2 bytes for each address, by simply defining the initial contents of the stack as data:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    org </span><span style=color:#ae81ff;>0x7c00

    </span><span style=color:#f92672;>jmp </span><span style=color:#ae81ff;>0</span><span style=color:#a6e22e;>:start
stack:
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>HERE
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>BASE
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>STATE
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>LATEST
start:
</span><span style=color:#75715e;>    ; ...
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>sp</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>stack
</span></code></pre><p>Even when a variable's address needs to be pushed onto the stack, this self-modifying code strategy saves bytes if a variable needs to be initialized — the best way to initialize a variable is to simply allocate it within the bootsector and <code>dw</code> the initial value there, which exactly evens out the stack data, and keeps the advantage of the shorter instruction encoding.<h2 id=initialization-code>Initialization code</h2><p>The first thing done after booting is setting up the <a href=https://en.wikipedia.org/wiki/X86_memory_segmentation>segment registers</a> and stack. The direction flag is also cleared, so that the string instructions work in the right direction.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#f92672;>jmp </span><span style=color:#ae81ff;>0</span><span style=color:#a6e22e;>:start
</span><span style=color:#75715e;>    ; ...
</span><span style=color:#a6e22e;>start:
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cs
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cs
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cs
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ds
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>es
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ss
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>sp</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>stack
    </span><span style=color:#f92672;>cld
</span></code></pre><p>There are a two notable things about this code. Firstly, segment registers are set through the stack. This is a byte-saving trick I've picked up from <code>bootBASIC</code> — it allows having to initialize a general-purpose register to zero:<pre style=background-color:#272822;>
<code class=language-lst data-lang=lst><span style=color:#75715e;>31c0    </span><span style=color:#f92672;>xor </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#75715e;>  ; through AX - 8 bytes
8ed8    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ds</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax
</span><span style=color:#75715e;>8ec0    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>es</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax
</span><span style=color:#75715e;>8ed0    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ss</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax

</span><span style=color:#75715e;>0</span><span style=color:#a6e22e;>E      </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cs</span><span style=color:#75715e;>     ; through the stack - 6 bytes
0</span><span style=color:#a6e22e;>E      </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cs
</span><span style=color:#75715e;>0</span><span style=color:#a6e22e;>E      </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cs
</span><span style=color:#75715e;>1</span><span style=color:#a6e22e;>F      </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ds
</span><span style=color:#75715e;>07      </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>es
</span><span style=color:#75715e;>17      </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ss
</span></code></pre><p>Secondly, one would think that, while the stack is being repointed, a small race condition window occurs — if an interrupt happened between <code>pop ss</code> and <code>mov sp</code>, chaos could ensue if the previous value of SP was in an unlucky place in memory. Of course, I could just cross my fingers and hope this doesn't happen if the 2 bytes required to wrap this in an <code>cli</code>/<code>sti</code> pair were too much. However, it turns out that this trade-off is not necessary due to an obscure corner of the x86 architecture. To quote the Volume 2B of the <a href=https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html>x86 Software Developer's Manual</a>:<blockquote><p>Loading the SS register with a POP instruction<sup class=footnote-reference><a href=#pop-ss>4</a></sup> suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (POP ESP)<sup class=footnote-reference><a href=#pop-esp>5</a></sup> before an event can be delivered.</blockquote><p>After the segments, stack and direction flag are set up, the decompressor is ran. Crucially, it does not use the DL register, which contains the BIOS disk number from which we were booted. It is then poked into the implementation of <code>load</code> (which is in the compressed segment), and pushed onto the stack for later use by user code:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>DRIVE_NUMBER</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>dl
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>dx</span><span style=color:#75715e;> ; for FORTH code
</span></code></pre><h2 id=the-outer-interpreter>The Outer Interpreter</h2><p>At this point, we reach the <em>outer interpreter</em> - the part of a FORTH system that processes user input. The name "<em>outer</em> interpreter" distinguishes it from the <em>inner</em> interpreter, which is the component that coordinates the execution within a defined word, and consists of <code>NEXT</code>, <code>DOCOL</code>, <code>EXIT</code>, and <code>LIT</code>.<p>Normally, a FORTH would expose the building blocks of its outer interpreter as words in the dictionary, such as<ul><li><code>REFILL</code> (read a line of input from the currently executing source),<li><code>WORD</code> (parse a word from the input stream),<li><code>FIND</code> (look up a word in the dictionary),<li><code>>NUMBER</code> (convert a string to number).</ul><p>In Miniforth, no attention is paid to this practice at all. Dictionary headers cost bytes, and so does communicating only through the stack. In fact, <code>WORD</code> and <code>>NUMBER</code> are melded together into one routine that does the job of both — that way, the loop can be shared, which saves bytes.<p>This monolithic architecture also lets us decide that <code>BX</code> and <code>DI</code> are not reserved for the top of stack and the return stack pointer, respectively, while the outer interpreter is executing. This significantly helps with register starvation within these comparatively complex parts of the system. These registers are set up just before jumping to a word, and saved after it returns.<h2 id=keyboard-input>Keyboard input</h2><p>After initialization is completed, the code falls through to <code>ReadLine</code>, the routine for reading in an input line from the keyboard. We will also jump back here later, when the current line of input is exhausted. The input buffer is at <code>0x500</code>, directly after the <a href=https://www.matrix-bios.nl/system/bda.html>BDA</a>. While the idiomatic string format for FORTH uses a separate length field, this buffer is NULL-terminated, as that is easier to handle when parsing. The pointer to the unparsed fragment of the input is stored in <code>InputPtr</code>, which is the only variable which does <em>not</em> use the self-modification technique, as it does not need to be explicitly initialized — it naturally gets written to before it is read.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>InputBuf </span><span style=color:#66d9ef;>equ </span><span style=color:#ae81ff;>0x500
</span><span style=color:#a6e22e;>InputPtr </span><span style=color:#66d9ef;>equ </span><span style=color:#ae81ff;>0xa02</span><span style=color:#75715e;> ; dw

</span><span style=color:#a6e22e;>ReadLine:
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>InputBuf
    </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>di
</span><span style=color:#a6e22e;>.</span><span style=color:#f92672;>loop</span><span style=color:#a6e22e;>:
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ah</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0
    </span><span style=color:#f92672;>int </span><span style=color:#ae81ff;>0x16
    </span><span style=color:#f92672;>cmp </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0x0d
    </span><span style=color:#f92672;>je </span><span style=color:#a6e22e;>short .</span><span style=color:#f92672;>enter
    stosb
    cmp </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0x08
    </span><span style=color:#f92672;>jne </span><span style=color:#a6e22e;>short .write
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>cmp </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>InputBuf</span><span style=color:#75715e;> ; underflow check
    </span><span style=color:#f92672;>je </span><span style=color:#a6e22e;>short .</span><span style=color:#f92672;>loop
    dec </span><span style=font-style:italic;color:#fd971f;>di
</span><span style=color:#a6e22e;>.write:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>PutChar
    </span><span style=color:#f92672;>jmp </span><span style=color:#a6e22e;>short .</span><span style=color:#f92672;>loop
</span><span style=color:#a6e22e;>.</span><span style=color:#f92672;>enter</span><span style=color:#a6e22e;>:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>PutChar
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0x0a
    </span><span style=color:#f92672;>int </span><span style=color:#ae81ff;>0x10
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#75715e;> ; write the null terminator by using the BX = 0 from PutChar
    </span><span style=color:#f92672;>stosb
</span><span style=color:#a6e22e;>InterpreterLoop:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>ParseWord</span><span style=color:#75715e;> ; returns length in CX. Zero implies no more input.
    </span><span style=color:#a6e22e;>jcxz short ReadLine
</span></code></pre><p>The BIOS interrupt for getting a character from the keyboard does not print the key — we have to do that ourselves. This is done with the "TELETYPE OUTPUT" function, which already handles special characters like backspace or newline.<pre style=background-color:#272822;>
<code><span style=color:#f8f8f2;>PutChar:
    xor bx, bx
    mov ah, 0x0e
    int 0x10
    ret
</span></code></pre><p>This function has its deficiencies. For example, the icky CRLF line endings are needed (CR to move the cursor to the beginning of the line, and LF to move it to the next line). Also, the backspace character only moves the cursor back a character, and does not erase it. To get the behavior we've come to expect, it would be necessary to print <code>\b \b</code> (to be fair, this is also the case on modern terminals). I chose to skip that.<p>Finally, <a href=http://www.ctyme.com/rbrown.htm>Ralf Brown's Interrupt List</a> mentions that some BIOSes clobber BP when the printed character causes the screen to scroll. This does not concern us, as we do not use this register at all.<h2 id=parsing>Parsing</h2><p>After we read in a line, we need to parse it into words. This is done on demand — each word is executed (or compiled, depending on the state), as soon as it is parsed. Apart from the interpreter loop, <code>ParseWord</code> is also called by the implementation of <code>:</code> (to get the name of the word being defined).<p>As mentioned before, this routine also computes the numeric value of the word, with the assumption that it's valid. There is no error checking in this regard — if a word is not found in the dictionary, its numeric value is pushed, which is probably nonsense if this wasn't intended.<p>We start out by skipping any whitespace in the input buffer:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>; returns
; DX = pointer to string
; CX = string length
; BX = numeric value
; clobbers SI and BP
</span><span style=color:#a6e22e;>ParseWord:
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, [</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>]
</span><span style=color:#75715e;>    ; repe scasb would probably save some bytes here if the registers worked out - scasb
    ; uses DI instead of SI :(
</span><span style=color:#a6e22e;>.skiploop:
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>dx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#75715e;> ; if we exit the loop in this iteration, dx will point to the first letter
               ; of the word
    </span><span style=color:#f92672;>lodsb
    cmp </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>" "
    </span><span style=color:#f92672;>je </span><span style=color:#a6e22e;>short .skiploop
</span></code></pre><p>Note the way the pointer to the beginning of the string is saved. The loop will go one byte past the whitespace, so storing it after the loop would require a separate decrement. Instead, we update the register with each iteration of the loop, but before the pointer is incremented by <code>lodsb</code>.<p>At this point, the <code>AL</code> register is loaded with the first character of the word. Thus our next loop will need to do <code>lodsb</code> at its <em>end</em>.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#f92672;>xor </span><span style=font-style:italic;color:#fd971f;>cx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>cx
    </span><span style=color:#f92672;>xor </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx
</span><span style=color:#a6e22e;>.takeloop:
    </span><span style=color:#f92672;>and </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>~</span><span style=color:#ae81ff;>0x20
    </span><span style=color:#f92672;>jz </span><span style=color:#a6e22e;>short Return</span><span style=color:#75715e;> ; jump to a borrowed `ret` from some other routine
</span></code></pre><p>This <code>and</code> instruction is interesting, as it does three things at once. It detects both spaces and null bytes in one fell swoop, but also also turns off the bit that differs between uppercase and lowercase letters, which allows handling both cases of hexadecimal numbers at no extra cost.<p>If we haven't detected the end of the word, we increment the length counter and convert the digit to its numeric value:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#f92672;>inc </span><span style=font-style:italic;color:#fd971f;>cx
    </span><span style=color:#f92672;>sub </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"0" </span><span style=color:#a6e22e;>&~</span><span style=color:#ae81ff;>0x20
    </span><span style=color:#f92672;>cmp </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>9
    </span><span style=color:#f92672;>jbe </span><span style=color:#a6e22e;>.digit_ok
    </span><span style=color:#f92672;>sub </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"A" </span><span style=color:#f8f8f2;>- </span><span style=color:#a6e22e;>(</span><span style=color:#e6db74;>"0" </span><span style=color:#a6e22e;>&~</span><span style=color:#ae81ff;>0x20</span><span style=color:#a6e22e;>) </span><span style=color:#f8f8f2;>- </span><span style=color:#ae81ff;>10
</span><span style=color:#a6e22e;>.digit_ok
    </span><span style=color:#f92672;>cbw
</span></code></pre><p><code>cbw</code> is a little-known instruction that converts a signed number from <code>b</code>yte to <code>w</code>ord, but for us it's just a shorter <code>mov ah, 0</code>. In a perhaps similar vein, we use the signed multiply <code>imul</code>, because it has more options for how it uses the registers than the unsigned <code>mul</code>. The particular form used here allows multiplying by an immediate and doesn't overwrite <code>DX</code> with the upper half of the product.<sup class=footnote-reference><a href=#imul>6</a></sup><p>This particular instruction needs to be encoded manually to force the literal width to be 2 bytes wide.<sup class=footnote-reference><a href=#base-dw>7</a></sup><pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>    ; imul bx, bx, &LTBASE> but yasm insists on encoding the immediate in just one byte...
    </span><span style=color:#66d9ef;>db </span><span style=color:#ae81ff;>0x69</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0xdb
</span><span style=color:#a6e22e;>BASE </span><span style=color:#66d9ef;>equ </span><span style=color:#a6e22e;>$
    </span><span style=color:#66d9ef;>dw </span><span style=color:#ae81ff;>16
    </span><span style=color:#f92672;>add </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#75715e;> ; add the new digit
</span></code></pre><p>Finally, we set up for the next iteration of the loop. We use a similar trick as before, where a pointer result is updated in each iteration to avoid a separate decrement at the end — we need to make sure that the input pointer doesn't point after the terminator.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>si
    </span><span style=color:#f92672;>lodsb
    jmp </span><span style=color:#a6e22e;>short .takeloop
</span></code></pre><h2 id=dictionary-lookup>Dictionary Lookup</h2><p>After a word is parsed, we try to look it up in the dictionary. For each entry, we need to compare the length of the name, and if it matches, the name itself. By including <code>F_HIDDEN</code> in the mask, we automatically handle hidden entries, too. The way we're comparing the length might look a bit weird. The goal is to keep the <code>F_IMMEDIATE</code> bit in AL, so that we don't have to keep around the pointer to the header of this word.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>InterpreterLoop:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>ParseWord
    jcxz short ReadLine

</span><span style=color:#75715e;>; Try to find the word in the dictionary.
; SI = dictionary pointer
; DX = string pointer
; CX = string length
; Take care to preserve BX, which holds the numeric value.
</span><span style=color:#a6e22e;>LATEST </span><span style=color:#66d9ef;>equ </span><span style=color:#a6e22e;>$</span><span style=color:#f8f8f2;>+</span><span style=color:#ae81ff;>1
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0
</span><span style=color:#a6e22e;>.find:
    </span><span style=color:#f92672;>lodsw
    push </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#75715e;> ; save pointer to next entry
    </span><span style=color:#f92672;>lodsb
    xor </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>cl</span><span style=color:#75715e;> ; if the length matches, then AL contains only the flags
    </span><span style=color:#f92672;>test </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>F_HIDDEN | F_LENMASK
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>short .next

    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>dx
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cx
    </span><span style=color:#f92672;>repe </span><span style=color:#a6e22e;>cmpsb
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>cx
    </span><span style=color:#f92672;>je </span><span style=color:#a6e22e;>short .found
.next:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>si
    </span><span style=color:#f92672;>or </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>si
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>short .find

</span><span style=color:#75715e;>    ; If we reach this point, it's a number.
    ; ...

</span><span style=color:#a6e22e;>.found:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#75715e;> ; discard pointer to next entry
    ; When we get here, SI points to the code of the word, and AL contains
    ; the F_IMMEDIATE flag
</span></code></pre><p>This part shows another advantage of not splitting the interpreter into reusable chunks — we can easily exit into two different codepaths, based on the result of the lookup.<h2 id=should-we-execute-it>Should we execute it?</h2><p>The system can be in two possible states:<ul><li>interpreting — all words should be executed<li>compiling — immediate words should be executed</ul><p>In other words, a word should be executed if it is immediate, or we're interpreting. We store this flag in the immediate field of an <code>or</code> instruction — it will be set to 0 when compiling:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>    ; When we get here, SI points to the code of the word, and AL contains
    ; the F_IMMEDIATE flag
</span><span style=color:#a6e22e;>STATE </span><span style=color:#66d9ef;>equ </span><span style=color:#a6e22e;>$</span><span style=color:#f8f8f2;>+</span><span style=color:#ae81ff;>1
    </span><span style=color:#f92672;>or </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>1
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#75715e;> ; both codepaths need the pointer to be in AX
    </span><span style=color:#f92672;>jz </span><span style=color:#a6e22e;>short .compile

</span><span style=color:#75715e;>    ; Execute the word
    ; ...
</span></code></pre><p>The most important words that need to change the state are <code>:</code> and <code>;</code>, but they just jump to <code>[</code> and <code>]</code> — words that allow to temporarily drop back to interpreted mode while compiling a word. The typical usecase is to eagerly calculate the value of a constant expression:<pre style=background-color:#272822;>
<code class=language-forth data-lang=forth><span style=color:#f8f8f2;>: third-foo [ foos 3 cells + ] literal @ ;
</span></code></pre><p>Since the two values of <code>STATE</code> differ only by 1, we can switch between them with <code>inc</code> and <code>dec</code>. This has the disadvantage that they are no longer idempotent, but this shouldn't matter to well-written code:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode LBRACK</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"["</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>F_IMMEDIATE
    </span><span style=color:#f92672;>inc </span><span style=color:#66d9ef;>byte</span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>STATE</span><span style=color:#f8f8f2;>]

</span><span style=color:#a6e22e;>defcode RBRACK</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"]"
    </span><span style=color:#f92672;>dec </span><span style=color:#66d9ef;>byte</span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>STATE</span><span style=color:#f8f8f2;>]
</span></code></pre><h2 id=executing-the-word>Executing the word</h2><p>If we decided to execute the word, we retrieve <code>BX</code> and <code>DI</code>, and set up <code>SI</code> so that <code>NEXT</code> will jump back to <code>.executed</code>:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>    ; Execute the word
</span><span style=color:#a6e22e;>RetSP </span><span style=color:#66d9ef;>equ </span><span style=color:#a6e22e;>$</span><span style=color:#f8f8f2;>+</span><span style=color:#ae81ff;>1
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>RS0
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>.return
    </span><span style=color:#f92672;>jmp </span><span style=font-style:italic;color:#fd971f;>ax
</span><span style=color:#a6e22e;>.return:
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>.executed
.executed:
    </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>RetSP</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>jmp </span><span style=color:#a6e22e;>short InterpreterLoop
</span></code></pre><h2 id=handling-numbers>Handling numbers</h2><p>There is no <code>F_IMMEDIATE</code> flag for numbers, so we just need to check the state to decide. It's a simple comparison, but if we're clever enough, you can save a byte here. Let's look again at the code that searches the dictionary. What value will <code>AH</code> have when we reach the number case?<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>.find:
    </span><span style=color:#f92672;>lodsw
    push </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#75715e;> ; save pointer to next entry
    </span><span style=color:#f92672;>lodsb
    xor </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>cl</span><span style=color:#75715e;> ; if the length matches, then AL contains only the flags
    </span><span style=color:#f92672;>test </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>F_HIDDEN | F_LENMASK
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>short .next

    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>dx
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>cx
    </span><span style=color:#f92672;>repe </span><span style=color:#a6e22e;>cmpsb
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>cx
    </span><span style=color:#f92672;>je </span><span style=color:#a6e22e;>short .found
.next:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>si
    </span><span style=color:#f92672;>or </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>si
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>short .find

</span><span style=color:#75715e;>    ; AH = ?
</span></code></pre><p>Do you see it? At this point, AH is zero, since it contains the higher half of the pointer to the next word, which we know is NULL, as we just got to the end of the list. This allows us to check the value of <code>STATE</code> without loading it into a register or any immediate bytes:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>    ; It's a number. Push its value - we'll pop it later if it turns out we need to compile
    ; it instead.
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>cmp </span><span style=color:#66d9ef;>byte</span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>STATE</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>ah
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>short InterpreterLoop
</span><span style=color:#75715e;>    ; Otherwise, compile the literal.
    ; ...
</span></code></pre><h2 id=compiling-things>Compiling things</h2><p>The output pointer for the compilation process is called <code>HERE</code>. It starts out just after the decompressed data. The function that writes out a word into this area is called <code>COMMA</code>, since the FORTH word that does this is <code>,</code>.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>COMMA:
HERE </span><span style=color:#66d9ef;>equ </span><span style=color:#a6e22e;>$</span><span style=color:#f8f8f2;>+</span><span style=color:#ae81ff;>1
    </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>CompressedEnd</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>add </span><span style=color:#66d9ef;>word</span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>HERE</span><span style=color:#f8f8f2;>], </span><span style=color:#ae81ff;>2
    </span><span style=color:#f92672;>ret
</span></code></pre><p>It is used in a straight-forward way to compile both numbers and words. We can share the tail, though — compiling a word will jump into the middle of compiling a number:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>    ; Otherwise, compile the literal.
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>LIT
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>COMMA
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
</span><span style=color:#a6e22e;>.compile:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>COMMA
    </span><span style=color:#f92672;>jmp </span><span style=color:#a6e22e;>short InterpreterLoop
</span></code></pre><p>The last piece of the puzzle are <code>:</code> and <code>;</code>. Let's look at <code>:</code> first. Since <code>ParseWord</code> makes use of <code>BX</code> and <code>SI</code>, we need to save these registers. Moreover, since we're writing the many parts of a dictionary header, we'll load <code>HERE</code> to <code>DI</code> to streamline things. This is a lot of registers that we need to push. However, we don't actually need to modify any register, so we can just save <em>all</em> the registers with <code>pusha</code>.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode COLON</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>":"
    </span><span style=color:#f92672;>pusha
    mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, [</span><span style=color:#a6e22e;>HERE</span><span style=color:#f8f8f2;>]
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>MakeLink</span><span style=color:#75715e;>    ; link field
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>ParseWord
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>cx
    </span><span style=color:#f92672;>stosb</span><span style=color:#75715e;>            ; length field
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>dx
    </span><span style=color:#f92672;>rep movsb</span><span style=color:#75715e;>        ; name field

    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0xe8</span><span style=color:#75715e;>     ; call
    </span><span style=color:#f92672;>stosb
</span><span style=color:#75715e;>    ; The offset is defined as (call target) - (ip after the call instruction)
    ; That works out to DOCOL - (di + 2) = DOCOL - 2 - di
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>DOCOL </span><span style=color:#f8f8f2;>- </span><span style=color:#ae81ff;>2
    </span><span style=color:#f92672;>sub </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>stosw
    mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>HERE</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>popa
    jmp </span><span style=color:#a6e22e;>short RBRACK</span><span style=color:#75715e;> ; enter compilation mode
</span></code></pre><p><code>;</code> is much shorter. We merely need to compile <code>EXIT</code> and go back to interpretation mode:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode SEMI</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>";"</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>F_IMMEDIATE
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>EXIT
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>COMMA
    </span><span style=color:#f92672;>jmp </span><span style=color:#a6e22e;>short LBRACK
</span></code></pre><p>The way these words jump to another word at the end is quite convenient. Remember how the <code>NEXT</code>s are written out as part of the <code>defcode</code> of the next word? One of the words needs to be last in memory, and then it won't have any "next word" after it. <code>:</code> and <code>;</code> are perfect candidates for this, since they don't need a <code>NEXT</code> at all.<h2 id=loading-code-from-disk>Loading code from disk</h2><p>Since we don't want to type in disk routines on every boot, we need to include a way to run source code loaded from disk. A filesystem would be its own beast, but FORTH tradition has a minimalistic solution: the disk is simply divided into 1 KiB blocks, in which source code is stored, formatted as 16 lines of 64 characters. Then <code>load ( blknum -- )</code> will execute the block with the specified number.<p>We map block 0 into LBA 0 and 1, block 1 into LBA 2 and 3, and so on. This does mean that block 0 is partially taken by the MBR and LBA 1 is wasted, but I'm not particularily bothered by that.<p>Since the original BIOS service at <code>int 0x13 / ah = 0x02</code> requires CHS addressing, I decided to use the EDD extension variant (<code>ah = 0x42</code>). This does mean that floppies are not supported, but I wasn't planning on using any anyway.<p>To use the EDD interface, we need to build a <em>disk address packet</em>, which looks like this:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#66d9ef;>db </span><span style=color:#ae81ff;>0x10</span><span style=color:#75715e;> ; size of packet
    </span><span style=color:#66d9ef;>db </span><span style=color:#ae81ff;>0</span><span style=color:#75715e;>    ; reserved
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>sector_count
    </span><span style=color:#66d9ef;>dw </span><span style=color:#a6e22e;>buffer_offset</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>buffer_segment
    </span><span style=color:#66d9ef;>dq </span><span style=color:#a6e22e;>LBA
</span></code></pre><p>We use a hybrid strategy to create this packet. The first part is kept as data in the bootsector, but the rest is written at runtime, even if it doesn't change. The "template" needs to be in a place where we can write after it, so the perfect place is just before the compressed data:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>DiskPacket:
    </span><span style=color:#66d9ef;>db </span><span style=color:#ae81ff;>0x10</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0
</span><span style=color:#a6e22e;>.count:
    </span><span style=color:#66d9ef;>dw </span><span style=color:#ae81ff;>2
</span><span style=color:#a6e22e;>.buffer:
</span><span style=color:#75715e;>    ; rest is filled out at runtime, overwriting the compressed data,
    ; which isn't necessary anymore

</span><span style=color:#a6e22e;>CompressedData:
    </span><span style=color:#66d9ef;>times </span><span style=color:#a6e22e;>COMPRESSED_SIZE </span><span style=color:#66d9ef;>db </span><span style=color:#ae81ff;>0xcc
</span></code></pre><p>The first four bytes of the packet are random enough to be hardcoded. However, when it comes to the address of the buffer, we can do better. We will need to write said address to <code>InputPtr</code> anyway. The most direct way to do that takes six bytes:<pre style=background-color:#272822;>
<code class=language-lst data-lang=lst><span style=color:#75715e;>c706020a0006    </span><span style=color:#f92672;>mov </span><span style=color:#66d9ef;>word</span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>], </span><span style=color:#a6e22e;>BlockBuf
</span></code></pre><p>However, we can get that value in <code>AX</code> at no extra cost:<pre style=background-color:#272822;>
<code class=language-lst data-lang=lst><span style=color:#75715e;>b80006          </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>BlockBuf
</span><span style=color:#75715e;>a3020a          </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>ax
</span></code></pre><p>Thus, we can write these two bytes of the disk packet with only 1 byte of code:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode LOAD</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"load"
    </span><span style=color:#f92672;>pusha
    mov </span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>DiskPacket.buffer
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>BlockBuf
    </span><span style=color:#f92672;>mov </span><span style=color:#66d9ef;>word</span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>stosw
</span></code></pre><p>Next, we need to write the segment (<code>0000</code>) and the LBA (which ends in six <code>00</code> bytes). I like to think of the instructions corresponding to these like so:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>31c0    </span><span style=color:#f92672;>xor </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#75715e;>    ; LBA zeroes
</span><span style=color:#a6e22e;>ab      </span><span style=color:#f92672;>stosw</span><span style=color:#75715e;>         ; segment
</span><span style=color:#a6e22e;>d1e3    </span><span style=color:#f92672;>shl </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>1</span><span style=color:#75715e;>     ; LBA data
</span><span style=color:#ae81ff;>93      </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#75715e;>   ; LBA data
</span><span style=color:#a6e22e;>ab      </span><span style=color:#f92672;>stosw</span><span style=color:#75715e;>         ; LBA data
</span><span style=color:#ae81ff;>93      </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#75715e;>   ; segment
</span><span style=color:#a6e22e;>ab      </span><span style=color:#f92672;>stosw</span><span style=color:#75715e;>         ; LBA zeroes
</span><span style=color:#a6e22e;>ab      </span><span style=color:#f92672;>stosw</span><span style=color:#75715e;>         ; LBA zeroes
</span><span style=color:#a6e22e;>ab      </span><span style=color:#f92672;>stosw</span><span style=color:#75715e;>         ; LBA zeroes
</span></code></pre><p>That is, we write the six LBA zeroes in 5 bytes of code. Writing out the segment only took moving the <code>xor ax, ax</code> earlier, and an additional <code>stosw</code> and <code>xchg ax, bx</code>. Thus, it is neutral at 2 bytes (but we need to write it out in code so that the pointer is right for the rest of the packet). Lastly, of course, we have the actual LBA data, which changes.<p>While <code>AX</code> is zero, let's take this opportunity to poke in a null terminator after the buffer:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>    </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>BlockBuf.end</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>al
</span></code></pre><p>Now we're ready to call the BIOS function. If it errors out, we just loop, as recovering is complicated — the most annoying complication is that the sector count in the packet is overwritten by the number of sectors <em>successfully read</em>, which breaks our template.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>DRIVE_NUMBER </span><span style=color:#66d9ef;>equ </span><span style=color:#a6e22e;>$</span><span style=color:#f8f8f2;>+</span><span style=color:#ae81ff;>1
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>dl</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>ah</span><span style=color:#f8f8f2;>, </span><span style=color:#ae81ff;>0x42
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, </span><span style=color:#a6e22e;>DiskPacket
    </span><span style=color:#f92672;>int </span><span style=color:#ae81ff;>0x13
    </span><span style=color:#f92672;>jc </span><span style=color:#a6e22e;>short $
    </span><span style=color:#f92672;>popa
    pop </span><span style=font-style:italic;color:#fd971f;>bx
</span></code></pre><h2 id=printing-numbers>Printing numbers</h2><p><code>u.</code> prints an unsigned number, followed by a space. Since splitting the number into digits with division yields the least-significant digit first, we push the digits onto the stack, and then pop and print in a separate loop. The space is printed by pushing a fake "digit" that will get converted into a space. This also lets us detect when we popped all the digits — the printing loop stops when it just printed a space.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode UDOT</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"u."
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>push </span><span style=color:#e6db74;>" " </span><span style=color:#f8f8f2;>- </span><span style=color:#e6db74;>"0"
</span><span style=color:#a6e22e;>.split:
    </span><span style=color:#f92672;>xor </span><span style=font-style:italic;color:#fd971f;>dx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>dx
    </span><span style=color:#f92672;>div </span><span style=color:#66d9ef;>word</span><span style=color:#f8f8f2;>[</span><span style=color:#a6e22e;>BASE</span><span style=color:#f8f8f2;>]
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>dx
    </span><span style=color:#f92672;>or </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>.split
.print:
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>add </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"0"
    </span><span style=color:#f92672;>cmp </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"9"
    </span><span style=color:#f92672;>jbe </span><span style=color:#a6e22e;>.got_digit
    </span><span style=color:#f92672;>add </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"A" </span><span style=color:#f8f8f2;>- </span><span style=color:#e6db74;>"0" </span><span style=color:#f8f8f2;>- </span><span style=color:#ae81ff;>10
</span><span style=color:#a6e22e;>.got_digit:
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>PutChar
    </span><span style=color:#f92672;>cmp </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>" "
    </span><span style=color:#f92672;>jne </span><span style=color:#a6e22e;>short .print
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx
</span></code></pre><h2 id=s-string-poke><code>s:</code> — string poke</h2><p><code>s:</code> is a feature which is, I believe, uniquely relevant to bootstrapping. This word takes the address of a buffer, and copies the rest of the current input line there. Without this, a significant amount of code would've had to be typed in twice: first to actually run it and bootstrap a disk block editor, and then again to actually save it on disk.<p>The implementation is just a simple loop, but the setup around it is noteworthy — we want to load the input pointer into <code>SI</code>, but we also need to preserve <code>SI</code> so that we can return properly. By using <code>xchg</code>, we can preserve it in <code>[InputPtr]</code> for the duration of the copy, at no extra cost:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#75715e;>;; Copies the rest of the line to buf.
</span><span style=color:#a6e22e;>defcode LINE</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"s:"</span><span style=color:#75715e;> ; ( buf -- buf+len )
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, [</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>]
</span><span style=color:#a6e22e;>.copy:
    </span><span style=color:#f92672;>lodsb
    mov </span><span style=color:#f8f8f2;>[</span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>al
    </span><span style=color:#f92672;>inc </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>or </span><span style=font-style:italic;color:#fd971f;>al</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>al
    </span><span style=color:#f92672;>jnz </span><span style=color:#a6e22e;>short .copy
.done:
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>si
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>si</span><span style=color:#f8f8f2;>, [</span><span style=color:#a6e22e;>InputPtr</span><span style=color:#f8f8f2;>]
</span></code></pre><p>The destination pointer is kept in <code>BX</code>. While writing at <code>DI</code> would only take a <code>stosb</code>, getting the pointer in and out of <code>DI</code> outweights this benefit. At the end, we leave a pointer to the null terminator on the stack. That way, you can continue the string by just using <code>s:</code> again on the next line. Since we don't skip any leading whitespace, this is even guaranteed to be properly spaced.<h2 id=other-primitives>Other primitives</h2><p>Choosing the primitives to include in Miniforth is perhaps the biggest tradeoff to be made. I am fully expecting that some more primitive words will need to be defined at runtime by poking in opcodes, but hopefully most of these opcodes will be generated by a simple FORTH assembler.<p>Arithmetic as basic as <code>+</code> is indispensible. I am defining both <code>+</code> and <code>-</code>, though, if I wanted to fit in something more important, I could keep only <code>-</code> and later define <code>: negate 0 swap - ;</code> and <code>: + negate - ;</code>.<p>Like any low-level programming language, we need a way to peek and poke values into memory. The implementation of <code>!</code> is particularily nice, since we can just pop directly into <code>[bx]</code>:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode PEEK</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"@"</span><span style=color:#75715e;> ; ( addr -- val )
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, [</span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>]

</span><span style=color:#a6e22e;>defcode POKE</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"!"</span><span style=color:#75715e;> ; ( val addr -- )
    </span><span style=color:#f92672;>pop </span><span style=color:#66d9ef;>word </span><span style=color:#f8f8f2;>[</span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>]
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx
</span></code></pre><p>There also are variants that read and write only a single byte:<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode CPEEK</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"c@"</span><span style=color:#75715e;> ; ( addr -- ch )
    </span><span style=color:#f92672;>movzx </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=color:#66d9ef;>byte</span><span style=color:#f8f8f2;>[</span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>]

</span><span style=color:#a6e22e;>defcode CPOKE</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"c!"</span><span style=color:#75715e;> ; ( ch addr -- )
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>mov </span><span style=color:#f8f8f2;>[</span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>], </span><span style=font-style:italic;color:#fd971f;>al
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx
</span></code></pre><p>We certainly need some stack manipulation words. <code>dup</code> and <code>drop</code> have dead simple implementations, and <code>swap</code> is definitely too useful to skip it.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode DUP</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"dup"</span><span style=color:#75715e;> ; ( a -- a a )
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx

</span><span style=color:#a6e22e;>defcode DROP</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"drop"</span><span style=color:#75715e;> ; ( a -- )
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx

</span><span style=color:#a6e22e;>defcode SWAP</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"swap"</span><span style=color:#75715e;> ; ( a b -- b a )
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx
</span></code></pre><p>I chose to also include <code>>r</code> and <code>r></code>, which allow using the return stack as a second stack for values (but, obviously, only within a single word). This is quite powerful. In fact, combined with <code>dup</code>, <code>drop</code> and <code>swap</code>, they allow you to implement any stack manipulation word you can imagine.<sup class=footnote-reference><a href=#stack-complete>8</a></sup><pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode TO_R</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>">r"
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>ax</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>stosw
    pop </span><span style=font-style:italic;color:#fd971f;>bx

</span><span style=color:#a6e22e;>defcode FROM_R</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"r>"
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>dec </span><span style=font-style:italic;color:#fd971f;>di
    </span><span style=color:#f92672;>push </span><span style=font-style:italic;color:#fd971f;>bx
    </span><span style=color:#f92672;>mov </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, [</span><span style=font-style:italic;color:#fd971f;>di</span><span style=color:#f8f8f2;>]
</span></code></pre><p>Finally, <code>emit</code> prints a character. This is far enough from the critical path of the bootstrap, that I would be comfortable with removing this one if need be.<pre style=background-color:#272822;>
<code class=language-asm data-lang=asm><span style=color:#a6e22e;>defcode EMIT</span><span style=color:#f8f8f2;>, </span><span style=color:#e6db74;>"emit"
    </span><span style=color:#f92672;>xchg </span><span style=font-style:italic;color:#fd971f;>bx</span><span style=color:#f8f8f2;>, </span><span style=font-style:italic;color:#fd971f;>ax
    </span><span style=color:#f92672;>call </span><span style=color:#a6e22e;>PutChar
    </span><span style=color:#f92672;>pop </span><span style=font-style:italic;color:#fd971f;>bx
</span></code></pre><h2 id=conclusion>Conclusion</h2><p>I am pleased with how this turned out. For a system constrained to the boot sector, I can pretty much call it feature-complete — I can't think of anything that would significantly simplify the bootstrap, while taking few enough bytes that it seems remotely within the reach of code golf. This is largely thanks to Ilya Kurdyukov's help — without it, I wouldn't have been able to fit <code>s:</code> in.<p>I've found an old PC I can use for my experiments. It boots Miniforth just fine:<p><img src=./hardware.jpg><p>I will be documenting my journey of building upon Miniforth in future posts on this blog. If that sounds like your cup of tea (and it probably does if you've read this far), consider subscribing to the Atom feed or <a href=https://twitter.com/NieDzejkob>following me on Twitter</a> to get notified about new posts.<hr><div class=footnote-definition id=ascii-x86><sup class=footnote-definition-label>1</sup><p>And even if that wasn't the case, there are <a href=https://en.wikipedia.org/wiki/EICAR_test_file#Design>many</a>, <a href=http://tom7.org/abc/>many</a> <a href=https://github.com/pts/pts-xcom>examples</a> of x86 code written with the printable subset of ASCII. I've even <a href=https://codegolf.stackexchange.com/questions/155018/the-programming-language-quiz-mark-ii-cops/155023#155023>done it myself</a> once a few years ago.</div><div class=footnote-definition id=disagree><sup class=footnote-definition-label>2</sup><p>If you, dear reader, find this unsatisfactory, I would like to invite you on your own journey of bootstrapping. It's really quite fun!</div><div class=footnote-definition id=compress-savings><sup class=footnote-definition-label>3</sup><p>The exact savings at the moment are somewhat hard to calculate, because some words don't make use of the <code>NEXT</code> being appended.</div><div class=footnote-definition id=pop-ss><sup class=footnote-definition-label>4</sup><p>While this passage of the reference only talks about <code>pop ss</code>, an analogous statement is made in the documentation for <code>mov</code>.</div><div class=footnote-definition id=pop-esp><sup class=footnote-definition-label>5</sup><p>This seems to be one of the many mistakes in the SDM — using a <code>pop esp</code> for this wouldn't work. Section 6.8.3 ("Masking Exceptions and Interrupts When Switching Stacks") in Volume 3A clarifies that all single-instruction ways to load <code>SP</code> work for this. I would've quoted that section instead, if not for the fact that, while it lists many more types of events that are suppressed, it actually fails to mention actual interrupts as one of them. That section does mention some interesting edge-cases, though. For example, if you're like me, you might be wondering what happens if many instructions in a row write to <code>SS</code>. The answer is that only the first one is guaranteed to suppress interrupts.</div><div class=footnote-definition id=imul><sup class=footnote-definition-label>6</sup><p>I suppose it makes sense that this option is only available for <code>imul</code>, since, by modular arithmetic, the only difference between a signed and unsigned multiply is in the upper half of the product, which we are discarding here. Immediates could be useful with <code>mul</code> too, though...</div><div class=footnote-definition id=base-dw><sup class=footnote-definition-label>7</sup><p>You might ask, why not just declare that <code>BASE</code> is a byte-sized variable? The answer is that <code>u.</code>, which is the word that prints a number, uses <code>div word[BASE]</code>, so that the result is still 16-bit.</div><div class=footnote-definition id=stack-complete><sup class=footnote-definition-label>8</sup><p>This does not include words like <code>PICK</code> — you would need loops for that. Anything definable as <code>( &LTlist of names> -- &LTlist of names> )</code> is fair game, though. Proving this fact is left as <a href=https://abstrusegoose.com/12>an exercise to the reader</a>.<sup class=footnote-reference><a href=#exercise>9</a></sup></div><div class=footnote-definition id=exercise><sup class=footnote-definition-label>9</sup><p>Seriously though, try to devise an infallible strategy for turning a stack effect into a sequence of words that implement it. It's a nice problem.</div></main><footer><div class=main-column><span class=social-links data-license="CC-BY 4.0 https://fontawesome.com/license"> <a href=https://twitter.com/NieDzejkob target=_blank><svg aria-hidden=true focusable=false data-prefix=fab data-icon=twitter class="svg-inline--fa fa-twitter fa-w-16"role=img xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><path fill=currentColor d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a> <a href=https://github.com/NieDzejkob target=_blank><svg aria-hidden=true focusable=false data-prefix=fab data-icon=github class="svg-inline--fa fa-github fa-w-16"role=img xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path fill=currentColor d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a> <a href=https://keybase.io/niedzejkob target=_blank><svg aria-hidden=true focusable=false data-prefix=fab data-icon=keybase class="svg-inline--fa fa-keybase fa-w-14"role=img xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path fill=currentColor d="M286.17 419a18 18 0 1 0 18 18 18 18 0 0 0-18-18zm111.92-147.6c-9.5-14.62-39.37-52.45-87.26-73.71q-9.1-4.06-18.38-7.27a78.43 78.43 0 0 0-47.88-104.13c-12.41-4.1-23.33-6-32.41-5.77-.6-2-1.89-11 9.4-35L198.66 32l-5.48 7.56c-8.69 12.06-16.92 23.55-24.34 34.89a51 51 0 0 0-8.29-1.25c-41.53-2.45-39-2.33-41.06-2.33-50.61 0-50.75 52.12-50.75 45.88l-2.36 36.68c-1.61 27 19.75 50.21 47.63 51.85l8.93.54a214 214 0 0 0-46.29 35.54C14 304.66 14 374 14 429.77v33.64l23.32-29.8a148.6 148.6 0 0 0 14.56 37.56c5.78 10.13 14.87 9.45 19.64 7.33 4.21-1.87 10-6.92 3.75-20.11a178.29 178.29 0 0 1-15.76-53.13l46.82-59.83-24.66 74.11c58.23-42.4 157.38-61.76 236.25-38.59 34.2 10.05 67.45.69 84.74-23.84.72-1 1.2-2.16 1.85-3.22a156.09 156.09 0 0 1 2.8 28.43c0 23.3-3.69 52.93-14.88 81.64-2.52 6.46 1.76 14.5 8.6 15.74 7.42 1.57 15.33-3.1 18.37-11.15C429 443 434 414 434 382.32c0-38.58-13-77.46-35.91-110.92zM142.37 128.58l-15.7-.93-1.39 21.79 13.13.78a93 93 0 0 0 .32 19.57l-22.38-1.34a12.28 12.28 0 0 1-11.76-12.79L107 119c1-12.17 13.87-11.27 13.26-11.32l29.11 1.73a144.35 144.35 0 0 0-7 19.17zm148.42 172.18a10.51 10.51 0 0 1-14.35-1.39l-9.68-11.49-34.42 27a8.09 8.09 0 0 1-11.13-1.08l-15.78-18.64a7.38 7.38 0 0 1 1.34-10.34l34.57-27.18-14.14-16.74-17.09 13.45a7.75 7.75 0 0 1-10.59-1s-3.72-4.42-3.8-4.53a7.38 7.38 0 0 1 1.37-10.34L214 225.19s-18.51-22-18.6-22.14a9.56 9.56 0 0 1 1.74-13.42 10.38 10.38 0 0 1 14.3 1.37l81.09 96.32a9.58 9.58 0 0 1-1.74 13.44zM187.44 419a18 18 0 1 0 18 18 18 18 0 0 0-18-18z"></path></svg></a> </span></div></footer></body><script data-goatcounter=https://niedzejkob.goatcounter.com/count async src=//gc.zgo.at/count.js></script>